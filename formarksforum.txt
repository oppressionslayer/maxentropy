Rand's first 1000 digits:
1009732533765201358634673548768095909117392927494537542048056489474296248052403720636104020082291665084226895319645093032320902560159533476435080336069901902529093767071538311311658867674397044362765912807999708015736147640323665398951168771217176833660657471734072768503669736170658133988511199291703106010805455718240635303426148679907439234030973285269776020205165692686657481873053852471862388579635733213505325470489055357548284682870983491256247379645753035296477835808342826093520344352738843598520177671490568607221094055860970934335050073998118050543139808277325072568248294052420152775678518345299634062889808313746700781847540610687117781788685402008650758401367666795190364764932960911062995946734887517649699182608928937856136823478341136548117674174685095058047769747303957186402181654480124356351772708015453182237421115782531438553763743509981777402772144323600210455216423796286026556991626803662522914836936872037662113990944005641809893205051422568514464275678896297788225438214598

In [1605]: next_prime(int(a[0:1000]))                                                                                                                                          
Out[1605]: 1009732533765201358634673548768095909117392927494537542048056489474296248052403720636104020082291665084226895319645093032320902560159533476435080336069901902529093767071538311311658867674397044362765912807999708015736147640323665398951168771217176833660657471734072768503669736170658133988511199291703106010805455718240635303426148679907439234030973285269776020205165692686657481873053852471862388579635733213505325470489055357548284682870983491256247379645753035296477835808342826093520344352738843598520177671490568607221094055860970934335050073998118050543139808277325072568248294052420152775678518345299634062889808313746700781847540610687117781788685402008650758401367666795190364764932960911062995946734887517649699182608928937856136823478341136548117674174685095058047769747303957186402181654480124356351772708015453182237421115782531438553763743509981777402772144323600210455216423796286026556991626803662522914836936872037662113990944005641809893205051422568514464275678896297788225438214603


RANDs first 1000 digits next prime XOR'd by 13 is the RAND's files first 1000 digits. IT is my believe, that anyone can use the following equation ( with enough CPU power) to recreate RANDs random number.  Is there anyone with enough CPU power to calculate RANDs random numbers next prime? If so you can beat the challenge. I'm sure google, would forgo the $100 dollars awarded to that equation. 

next_prime(int(a[0:1000])) ^13  # Equals RANDs first 1000 digits. Effectively, i've recreated the first 1000 digits of RANDS number with a prime. Somewhere someone has a database of these primes. If ordered correctly, the lookup could be super easy, and we could use a formula that recreates the random number using that database.  Anyone have any comments on this?

next_prime(int(a[0:1000])) ^13  = 1009732533765201358634673548768095909117392927494537542048056489474296248052403720636104020082291665084226895319645093032320902560159533476435080336069901902529093767071538311311658867674397044362765912807999708015736147640323665398951168771217176833660657471734072768503669736170658133988511199291703106010805455718240635303426148679907439234030973285269776020205165692686657481873053852471862388579635733213505325470489055357548284682870983491256247379645753035296477835808342826093520344352738843598520177671490568607221094055860970934335050073998118050543139808277325072568248294052420152775678518345299634062889808313746700781847540610687117781788685402008650758401367666795190364764932960911062995946734887517649699182608928937856136823478341136548117674174685095058047769747303957186402181654480124356351772708015453182237421115782531438553763743509981777402772144323600210455216423796286026556991626803662522914836936872037662113990944005641809893205051422568514464275678896297788225438214598


Also, i have found a way to recreate some weak primes, with cool math and the powers of other numbers, like this random number has a weak prime, so we can get to that random number quite easily, read on! :
meaning we could possibly further reduce the RANDs previous and next prime if it's weak: Here are two examples (i'm looking for an example to recreate strong primes and with my resolve, i'll post one when i find it):


Random Number with weak near prime: 694047297735108884694593330383634200900313667814547465109885556570628372850198847563871329031821376048306582930457050786069880611600189273069672720768178789443680578725716681012943709448107079571543789032792169529828443426785173572358617636284936837223561030713636170913361265814458945

zip zzweakrandom.zip zzweakrandom.bin 
  adding: zzweakrandom.bin (stored 0%)
  
Us creating that random number which zip can only store with an equation:
((13**141) + (24**161) + (27**199)) ^ 1009

Next Prime ( 694047297735108884694593330383634200900313667814547465109885556570628372850198847563871329031821376048306582930457050786069880611600189273069672720768178789443680578725716681012943709448107079571543789032792169529828443426785173572358617636284936837223561030713636170913361265814459011 )

Previous Prime ( 694047297735108884694593330383634200900313667814547465109885556570628372850198847563871329031821376048306582930457050786069880611600189273069672720768178789443680578725716681012943709448107079571543789032792169529828443426785173572358617636284936837223561030713636170913361265814458719 )

Next Primes Prime # ( For Weak/Strong Test ) ( 694047297735108884694593330383634200900313667814547465109885556570628372850198847563871329031821376048306582930457050786069880611600189273069672720768178789443680578725716681012943709448107079571543789032792169529828443426785173572358617636284936837223561030713636170913361265814461419

694047297735108884694593330383634200900313667814547465109885556570628372850198847563871329031821376048306582930457050786069880611600189273069672720768178789443680578725716681012943709448107079571543789032792169529828443426785173572358617636284936837223561030713636170913361265814459011 > (694047297735108884694593330383634200900313667814547465109885556570628372850198847563871329031821376048306582930457050786069880611600189273069672720768178789443680578725716681012943709448107079571543789032792169529828443426785173572358617636284936837223561030713636170913361265814458719 + 694047297735108884694593330383634200900313667814547465109885556570628372850198847563871329031821376048306582930457050786069880611600189273069672720768178789443680578725716681012943709448107079571543789032792169529828443426785173572358617636284936837223561030713636170913361265814461419)/2 

((13**141) + (24**161) + (27**199))^819 # recreates this weak prime. My contention is that if RANDS next and previous primes are weak, we could recreate the number based on this cool "possible" (we don't know yet) scenario of RANDS previous and next primes being possibly weak, Does that make sense?


((13**141) + (24**161) + (27**199))^819 = 694047297735108884694593330383634200900313667814547465109885556570628372850198847563871329031821376048306582930457050786069880611600189273069672720768178789443680578725716681012943709448107079571543789032792169529828443426785173572358617636284936837223561030713636170913361265814459011  #Which is prime, but weak.


Here is me using a formula to climb up to a strong prime of 10099, using powers of two, cool huh? So strong primes, can be created using math and algorithims and smaller numbers, just by div/2'ing a powers of 2 number. 8192 is 2**

climbtoprime=1571*4

y=2**13  # or 8192

for x in range(0,12):

  climbtoprime=climbtoprime^y

  y=y//2

print(climbtoprime+3)
